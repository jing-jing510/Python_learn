
## 闭包
```python
def sleep():
    import random
    import time
    print(("睡眠中"))
    time.sleep(random.randint(1,5))
def outer(func):
    def inner():
        print("睡觉")
        func()
        print("起床")
    return inner

fn =outer(sleep())
fn()
```
* 优点
  * 无需定义全局变量即可实现通过函数,持续的访问\修改某个值
    * nonlocal 在闭包函数中想要修改外部函数的变量值
  * 闭包使用的变量的所用于在函数内,难以被错误的调用修改
* 由于内部函数持续引用外部函数的值,所以会导致这一部分内存空间不被释放,一直占用内存

## 装饰器
也是一种闭包:在不破坏目标函数原有的代码和功能的前提下,为目标函数增加新功能.
```python
# 装饰器 @outer
def outer1(func):
    def inner():
        print("睡觉")
        func()
        print("起床")
    return inner
@outer1
def sleep():
    import random
    import time
    print(("睡眠中"))
    time.sleep(random.randint(1,5))
# 两个改动 一个@outer 一个是直接调用就可以了
sleep()
```
* 创建闭包函数,在闭包函内调用目标函数
* 写法
  * 写一个闭包,def outer(func)
  * @outer 调用
  * 原函数 sleep()

## 设计模式
编程套路
### 单例模式
* 创建类的实例后,可以得到完整的独立的类对象
* 地址不同
* 节省资源:创建单例模式
```python
class StrTools:
    pass
str_tool =StrTools()

# 在其他类当中
```
